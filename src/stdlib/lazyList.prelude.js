"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lazyListPrelude = void 0;
exports.lazyListPrelude = "\n\n// equal computes the structural equality\n// over its arguments\n\nfunction equal(xs, ys) {\n    return is_pair(xs)\n        ? (is_pair(ys) &&\n           equal(head(xs), head(ys)) &&\n           equal(tail(xs), tail(ys)))\n        : is_null(xs)\n        ? is_null(ys)\n        : is_number(xs)\n        ? (is_number(ys) && xs === ys)\n        : is_string(xs)\n        ? (is_string(ys) && xs === ys)\n        :  xs === ys;\n}\n\n// returns the length of a given argument list\n// assumes that the argument is a list\n\nfunction length(xs) {\n  return is_null(xs) ? 0 : 1 + length(tail(xs));\n}\n\n// map applies first arg f, assumed to be a unary function,\n// to the elements of the second argument, assumed to be a list.\n// f is applied element-by-element:\n// map(f, list(1, 2)) results in list(f(1), f(2))\n\nfunction map(f, xs) {\n  return is_null(xs) ? null : pair(f(head(xs)), map(f, tail(xs)));\n}\n\n// build_list takes a nonnegative integer n as first argument,\n// and a function fun as second argument.\n// build_list returns a list of n elements, that results from\n// applying fun to the numbers from 0 to n-1.\n\nfunction build_list(fun, n) {\n  function build(i, fun, already_built) {\n    return i < 0 ? already_built : build(i - 1, fun, pair(fun(i), already_built));\n  }\n  return build(n - 1, fun, null);\n}\n\n// for_each applies first arg fun, assumed to be a unary function,\n// to the elements of the second argument, assumed to be a list.\n// fun is applied element-by-element:\n// for_each(fun, list(1, 2)) results in the calls fun(1) and fun(2).\n// for_each returns true.\n\nfunction for_each(fun, xs) {\n  if (is_null(xs)) {\n    return true;\n  } else {\n    fun(head(xs));\n    return for_each(fun, tail(xs));\n  }\n}\n\n// list_to_string returns a string that represents the argument list.\n// It applies itself recursively on the elements of the given list.\n// When it encounters a non-list, it applies to_string to it.\n\nfunction list_to_string(xs) {\n    return is_null(xs)\n        ? \"null\"\n        : is_pair(xs)\n            ? \"[\" + list_to_string(head(xs)) + \",\" +\n                list_to_string(tail(xs)) + \"]\"\n            : stringify(xs);\n}\n\n// reverse reverses the argument, assumed to be a list\n\nfunction reverse(xs) {\n  function rev(original, reversed) {\n    return is_null(original) ? reversed : rev(tail(original), pair(head(original), reversed));\n  }\n  return rev(xs, null);\n}\n\n// append first argument, assumed to be a list, to the second argument.\n// In the result null at the end of the first argument list\n// is replaced by the second argument, regardless what the second\n// argument consists of.\n\nfunction append(xs, ys) {\n  return is_null(xs) ? ys : pair(head(xs), append(tail(xs), ys));\n}\n\n// member looks for a given first-argument element in the\n// second argument, assumed to be a list. It returns the first\n// postfix sublist that starts with the given element. It returns null if the\n// element does not occur in the list\n\nfunction member(v, xs) {\n  return is_null(xs) ? null : v === head(xs) ? xs : member(v, tail(xs));\n}\n\n// removes the first occurrence of a given first-argument element\n// in second-argument, assmed to be a list. Returns the original\n// list if there is no occurrence.\n\nfunction remove(v, xs) {\n  return is_null(xs) ? null : v === head(xs) ? tail(xs) : pair(head(xs), remove(v, tail(xs)));\n}\n\n// Similar to remove, but removes all instances of v\n// instead of just the first\n\nfunction remove_all(v, xs) {\n  return is_null(xs)\n    ? null\n    : v === head(xs)\n    ? remove_all(v, tail(xs))\n    : pair(head(xs), remove_all(v, tail(xs)));\n}\n\n// filter returns the sublist of elements of the second argument\n// (assumed to be a list), for which the given predicate function\n// returns true.\n\nfunction filter(pred, xs) {\n  return is_null(xs)\n    ? xs\n    : pred(head(xs))\n    ? pair(head(xs), filter(pred, tail(xs)))\n    : filter(pred, tail(xs));\n}\n\n// enumerates numbers starting from start, assumed to be a number,\n// using a step size of 1, until the number exceeds end, assumed\n// to be a number\n\nfunction enum_list(start, end) {\n  const newStart = start + 1;\n  return start > end ? null : pair(start, enum_list(newStart, end));\n}\n\n// Returns the item in xs (assumed to be a list) at index n,\n// assumed to be a nonnegative integer.\n// Note: the first item is at position 0\n\nfunction list_ref(xs, n) {\n  const rest = tail(xs);\n  return n === 0 ? head(xs) : list_ref(rest, n - 1);\n}\n\n// accumulate applies an operation op (assumed to be a binary function)\n// to elements of sequence (assumed to be a list) in a right-to-left order.\n// first apply op to the last element and initial, resulting in r1, then to\n// the  second-last element and r1, resulting in r2, etc, and finally\n// to the first element and r_n-1, where n is the length of the\n// list.\n// accumulate(op, zero, list(1, 2, 3)) results in\n// op(1, op(2, op(3, zero)))\n\nfunction accumulate(f, initial, xs) {\n  return is_null(xs) ? initial : f(head(xs), accumulate(f, initial, tail(xs)));\n}\n";
