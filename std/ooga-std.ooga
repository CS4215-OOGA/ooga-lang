// The Ooga Standard Library


// Formatting
type format struct {
}

func (f *format) Println(x any) {
    print(x)
}

// Concurrency

type Sync struct {}

type WaitGroup struct {
    counter int
}

func (s *Sync) NewWaitGroup(counter int) WaitGroup {
    wg := WaitGroup{counter};
    return wg;
}

func (wg *WaitGroup) Add(delta int) {
    startAtomic();
    wg.counter += delta
    endAtomic();
}

func (wg *WaitGroup) Done() {
    // update expressions are atomic
    wg.counter--
}

func (wg *WaitGroup) Wait() {
    for {
        startAtomic();
        if wg.counter <= 0 {
            endAtomic();
            break;
        }
        endAtomic();
        yieldThread(); // yield to avoid wasteful loop
    }
}

type Mutex struct {
    currentThread int
}

func (s *Sync) NewMutex() Mutex {
    m := Mutex{-1};
    return m;
}

func (m *Mutex) Lock() {
    for {
        startAtomic();
        id := m.currentThread;
        if (id == -1) {
            break; // finally pick up lock
        }
        // else
        endAtomic();
        blockThread(); // block and loop until can pick up lock
    }
    m.currentThread = getThreadID();
    endAtomic();
}

func (m *Mutex) Unlock() {
    startAtomic();
    if m.currentThread == getThreadID() {
        m.currentThread = -1;
    } else {
        oogaError(); // custom error since we don't currently support returning errors
    }
    endAtomic();
}

type Semaphore struct {
    count int
}

func (s *Sync) NewSemaphore(count int) Semaphore {
    s := Semaphore{count};
    return s;
}

func (s *Semaphore) Down() {
    for {
        startAtomic();
        if (s.count > 0) {
            s.count = s.count - 1;
            break;
        }
        endAtomic();
        blockThread();
    }
    endAtomic();
}

func (s *Semaphore) Up() {
    startAtomic();
    s.count = s.count + 1;
    endAtomic();
}

var fmt format = format{}


type Time struct {
}

// Duration to sleep for in milliseconds
func (t *Time) Sleep(duration int) {
    startTime := getTime();
    for {
        if getTime() - startTime >= duration {
            break;
        }
    }
}

var time Time = Time{};

var sync Sync = Sync{};
